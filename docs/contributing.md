# Contributing

# Основное

* Старайтесь максимально разбивать большие изменения на пачку маленьких и/или вносите их поэтапно. Чем больше пулл реквест - тем сложнее и дольше его проверять.
* Мы ожидаем, что вы поможете нам поддерживать код, который вы добавили. Скорее всего мы к вам обратимся в случае возникновения каких-то проблем, связанных с вашими изменениями, в том числе рантаймами или багами.
* Помимо разбиения кода по пулл реквестам - код так же стоит разбивать по модулям. Если вы добавляете какую-то новую логику, серьезно подумайте над тем, чтобы положить ее в отдельный, собственный файл, если нет каких-то то явных причин добавить его в существующий.
* Ваши изменения не должны содержать закомментированный код. В комментариях вместо того, чтобы объяснять ЧТО делает ваш код, пишите ЗАЧЕМ он это делает, если это необходимо.
* Пулл реквесты не должны содержать изменений, которые не относятся к функциональности, указанной в описании самого пулл реквеста и коммитов.
* Если пулл реквест вносит изменения касающиеся существующего Github иссуя - это должно быть указано в описаниях пулл реквеста и коммита. Например, "Fix broken floor sprites, close #23" (подробнее: https://help.github.com/articles/closing-issues-via-commit-messages).

# Code conventions

### Используйте абсолютные пути

DM позволяет писать код блоками:

```DM
datum
	datum1
		var
			varname1 = 1
			varname2
			static
				varname3
				varname4
		proc
			proc1()
				code
			proc2()
				code

		datum2
			varname1 = 0
			proc
				proc3()
					code
			proc2()
				..()
				code
```

Такой способ написания делает невозможным текстовый поиск функции или типа по коду. Единственное исключение - внутри блока описания типа можно определять переменные.

Тот же код, написанный правильно:

```DM
/datum/datum1
	var/varname1
	var/varname2
	var/static/varname3
	var/static/varname4

/datum/datum1/proc/proc1()
	code
/datum/datum1/proc/proc2()
	code
/datum/datum1/datum2
	varname1 = 0
/datum/datum1/datum2/proc/proc3()
	code
/datum/datum1/datum2/proc2()
	..()
	code
```

### Не избавляйтесь от проверки типов
Запрещено использовать оператор `:`. Всегда явно преобразуйте переменную к конкретному типу.

Плохой пример:
```DM
var/something_general_object = ...
something_general_object:specific_type_func()
```

Мы узнаем, что у something_general_object нет такой функции только когда запустим сервер. Более того, когда мы это узнаем - будет непонятным что это за тип, почему у него было этой функции и какой тип на самом деле ожидался. С другой стороны, в коде:

```DM
var/something_general_object
var/more/specified/type/O = object
ASSERT(istype(O)) // bad argument
O.specific_type_funс()
```

Мы явно указываем какой тип мы ожидаем и статически проверяем, что у этого типа есть такая функция.

### Пути типов всегда должны начинаться с /
Например: `/datum/thing`, вместо `datum/thing`

### Пути типов всегда должны быть в нижнем регистре
Например: `/datum/thing/blue`, вместо `datum/thing/BLUE` или `datum/thing/Blue`

### Явно определяйте переменные в формате var/name
DM позволяет определять переменные и другими способами, но всегда явно пишите `var` в целях консистентности. В том числе, это касается аргументов функций.

### Табы, а не пробелы.
Для интендации кода используйте табы!

(Вы можете использовать пробелы для выравнивания, но всегда сначала вставляйте отступ табами, а уже потом добавляйте пробелы в конце)

### Избегайте дублирования кода
Когда вы копируете один и тот же код в разные места - появляется необходимость одинаково поддерживать этот код в двух местах. При любом изменении оригинального кода надо помнить о копии этого кода в другом месте и зачастую вносить изменения и туда.

Чтобы избежать подобных проблем используйте наследование объектов друг от друга или же просто вынесите необходимую логику в отдельную функцию.

### Предпочитайте `Initialize()` вместо `New()` для atom (объектов, размещаемых на карте).
Контроллеры, используемые в нашей сборке, должны справляться с длительными операциями и лагами, но они не могут контролировать то, что происходит во время загрузки карты, когда для всех объектов вызывается New. Для любых новых объектов, без явной необходимости, используйте `Initialize`, чтобы сделать все, что вы хотели сделать в `New`. Это уменьшает количество функций вызываемых на этапе загрузки карты. Чтобы узнать больше про то, как работает `Initialize`, смотрите https://github.com/ChaoticOnyx/OnyxBay/blob/dev/code/game/atoms.dm

### Не используйте магические значения
Это касается различных переменных "mode", которые могут быть 1 или 2, но при этом неясно, что конкретно они означают. Используйте #define или локальные переменные, чтобы явно указать, что означает то или иное значение. Например:

```DM
/datum/proc/do_the_thing(thing_to_do)
	switch(thing_to_do)
		if(1)
			(...)
		if(2)
			(...)
```
Здесь неясно, что означают "1" и "2"! Вместо этого можно было бы написать:
```DM
/datum/proc/do_the_thing(thing_to_do)
	var/DO_THE_THING_REALLY_HARD = 1
	var/DO_THE_THING_EFFICIENTLY = 2
	
	switch(thing_to_do)
		if(DO_THE_THING_REALLY_HARD)
			(...)
		if(DO_THE_THING_EFFICIENTLY)
			(...)
```
Так получается гораздо понятнее, что увеличивает читаемость вашего кода.

### Операторы контроля выполнения
(if, while, for и другие)

* Все операторы контроля выполнения не должны содержать другого кода на той же строчке (`if (blah) return`)
* Все операторы контроля выполнения, сравнивающие переменную с каким-то значением, должны использовать формулу `переменная` `оператор` `значение`, не наоборот (например: `if (count <= 10)`, вместо `if (10 >= count)`)

### Используйте ранний return
Не стоит строчить многоуровневые конструкции из блоков if, когда того же результата можно достичь ранним возвратом из функции

Вот так делать не стоит:
````DM
/datum/datum1/proc/proc1()
	if (thing1)
		if (!thing2)
			if (thing3 == 30)
				do stuff
````
А так уже лучше:
````DM
/datum/datum1/proc/proc1()
	if (!thing1)
		return
	if (thing2)
		return
	if (thing3 != 30)
		return
	do stuff
````

### Разработка безопасного кода
* Всегда относитель к пользовательскому вводу так, как будто он намеренно пытается все сломать. Проверяйте пользовательский ввод на все случаи, которые не соответсвуют ожиданиям вашего кода. Для чисел проверяйте границы, для строк используйте escape-функции.
* Обязательно эскейптьте все команды к базе данных - используйте sanitizeSQL чтобы обработать весь текст от игроков и админов перед тем как передавать его в базу данных. Для чисел используйте isnum().
* Все вызовы топиков обязательно нужно проверять на их корректность. Такие вызовы могут быть подделаны со стороны клиента, поэтому их содержимым может быть что угодно!
* Скрывайте от игроков любую информацию, которая может быть использована для метагейма (даже такую простую, как количество игроков, которые нажали Declare, так как даже она может быть использована, чтобы вычислить текущий режим).
* Когда вы пишите код, который может каким-то образом влиять на раунд и генерировать *ВЕСЕЛЬЕ*, дважды проверьте, что такой функционал будет доступен только админам соответствующего ранга.

### Файлы
* Рантаймы не содержат полного пути до файла - поэтому избегайте одинаковых названий файлов даже в разных папках.
* Названия файлов не должны содержать пробелов или символов, которые придется эскейпить, указывая uri.
* Названия файлов и все пути всегда должны быть в нижнем регистре, чтобы избежать проблем, связанных с разным отношением к регистру в разных операционных системах.

### Operators
#### Spacing
(this is not strictly enforced, but more a guideline for readability's sake)

* Operators that should be separated by spaces
	* Boolean and logic operators like &&, || <, >, ==, etc (but not !)
	* Bitwise AND &
	* Argument separator operators like , (and ; when used in a forloop)
	* Assignment operators like = or += or the like
* Operators that should not be separated by spaces
	* Bitwise OR |
	* Access operators like . and :
	* Parentheses ()
	* logical not !

Math operators like +, -, /, *, etc are up in the air, just choose which version looks more readable.

#### Use
* Bitwise AND - '&'
	* Should be written as ```bitfield & bitflag``` NEVER ```bitflag & bitfield```, both are valid, but the latter is confusing and nonstandard.
* Associated lists declarations must have their key value quoted if it's a string
	* WRONG: list(a = "b")
	* RIGHT: list("a" = "b")

### Dream Maker Quirks/Tricks
Like all languages, Dream Maker has its quirks, some of them are beneficial to us, like these

#### In-To for-loops
```for(var/i = 1, i <= some_value, i++)``` is a fairly standard way to write an incremental for loop in most languages (especially those in the C family), but DM's ```for(var/i in 1 to some_value)``` syntax is oddly faster than its implementation of the former syntax; where possible, it's advised to use DM's syntax. (Note, the ```to``` keyword is inclusive, so it automatically defaults to replacing ```<=```; if you want ```<``` then you should write it as ```1 to some_value-1```).

HOWEVER, if either ```some_value``` or ```i``` changes within the body of the for (underneath the ```for(...)``` header) or if you are looping over a list AND changing the length of the list then you can NOT use this type of for-loop!

### for(var/A in list) VS for(var/i in 1 to list.len)
The former is faster than the latter, as shown by the following profile results:
https://file.house/zy7H.png
Code used for the test in a readable format:
https://pastebin.com/w50uERkG

## Global против static

В DM есть ключевое слово global, которое используется в трех случаях:

1. Внутри типа (или внутри функции) мы хотим определить переменную общую для всех объектов этого типа (для всех вызовов этой функции). (http://www.byond.com/docs/ref/#/var/global).
2. Внутри функции мы хотим использовать переменную из глобального скоупа, когда у нас в локальном скоупе уже есть переменная с таким же названием. (http://www.byond.com/docs/ref/#/proc/var/global)

Так как в первом случае речь идет не о видимости переменной, а том, что она общая для разных экземпляров типа (вызовов функции), то название ключевого слова global может кого-то запутать. Поэтому вместо него в первом случае мы стараемся использовать ключевое слово static, которое отсутствует в документации, но полностью заменяет global в этом случае и лучше описывает суть происходящего.

Отдельно обратите внимание, что все переменные в BYOND имеют глобальную видимость с точки зрения доступа, поэтому global (и static) в глобальном скоупе не имеет смысла и запрещено.
