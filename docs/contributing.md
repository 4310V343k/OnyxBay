# Contributing

# Основное

* Старайтесь максимально разбивать большие изменения на пачку маленьких и/или вносите их поэтапно. Чем больше пулл реквест - тем сложнее и дольше его проверять.
* Мы ожидаем, что вы поможете нам поддерживать код, который вы добавили. Скорее всего мы к вам обратимся в случае возникновения каких-то проблем, связанных с вашими изменениями, в том числе рантаймами или багами.
* Помимо разбиения кода по пулл реквестам - код так же стоит разбивать по модулям. Если вы добавляете какую-то новую логику, серьезно подумайте над тем, чтобы положить ее в отдельный, собственный файл, если нет каких-то то явных причин добавить его в существующий.
* Ваши изменения не должны содержать закомментированный код. В комментариях вместо того, чтобы объяснять ЧТО делает ваш код, пишите ЗАЧЕМ он это делает, если это необходимо.
* Пулл реквесты не должны содержать изменений, которые не относятся к функциональности, указанной в описании самого пулл реквеста и коммитов.
* Если пулл реквест вносит изменения касающиеся существующего Github иссуя - это должно быть указано в описаниях пулл реквеста и коммита. Например, "Fix broken floor sprites, close #23" (подробнее: https://help.github.com/articles/closing-issues-via-commit-messages).

# Code conventions

### Используйте абсолютные пути

DM позволяет писать код блоками:

```DM
datum
	datum1
		var
			varname1 = 1
			varname2
			static
				varname3
				varname4
		proc
			proc1()
				code
			proc2()
				code

		datum2
			varname1 = 0
			proc
				proc3()
					code
			proc2()
				..()
				code
```

Такой способ написания делает невозможным текстовый поиск функции или типа по коду. Единственное исключение - внутри блока описания типа можно определять переменные.

Тот же код, написанный правильно:

```DM
/datum/datum1
	var/varname1
	var/varname2
	var/static/varname3
	var/static/varname4

/datum/datum1/proc/proc1()
	code
/datum/datum1/proc/proc2()
	code
/datum/datum1/datum2
	varname1 = 0
/datum/datum1/datum2/proc/proc3()
	code
/datum/datum1/datum2/proc2()
	..()
	code
```

### Не избавляйтесь от проверки типов
Запрещено использовать оператор `:`. Всегда явно преобразуйте переменную к конкретному типу.

Плохой пример:
```DM
var/something_general_object = ...
something_general_object:specific_type_func()
```

Мы узнаем, что у something_general_object нет такой функции только когда запустим сервер. Более того, когда мы это узнаем - будет непонятным что это за тип, почему у него было этой функции и какой тип на самом деле ожидался. С другой стороны, в коде:

```DM
var/something_general_object
var/more/specified/type/O = object
ASSERT(istype(O)) // bad argument
O.specific_type_funс()
```

Мы явно указываем какой тип мы ожидаем и статически проверяем, что у этого типа есть такая функция.

### Пути типов всегда должны начинаться с /
Например: `/datum/thing`, вместо `datum/thing`

### Пути типов всегда должны быть в нижнем регистре
Например: `/datum/thing/blue`, вместо `datum/thing/BLUE` или `datum/thing/Blue`

### Использование ключевого слова `var`
Локальные переменные всегда определяйте в формате `var/type/name`, вместо `var type/name`. В аргументах функций оно избыточно, поэтому всегда опускаем и пишем просто `type/name`. 

### Для интендации всегда табы, для выравнивания - пробелы
Интендация - это отступы от начала строки. Всегда ставим отступы только табами, иначе будут проблемы с компиляцией. Если есть необходимость выравнять код - делаем это пробелами, чтобы не разъезжалось в редакторах с разной длиной табуляции.

### Избегайте дублирования кода
Когда вы копируете один и тот же код в разные места - появляется необходимость одинаково поддерживать этот код в двух местах. При любом изменении оригинального кода надо помнить о копии этого кода в другом месте и зачастую вносить изменения и туда.

Чтобы избежать подобных проблем используйте наследование объектов друг от друга или же просто вынесите необходимую логику в отдельную функцию.

### Предпочитайте `Initialize()` вместо `New()` для atom (объектов, размещаемых на карте).
Контроллеры, используемые в нашей сборке, должны справляться с длительными операциями и лагами, но они не могут контролировать то, что происходит во время загрузки карты, когда для всех объектов вызывается New. Для любых новых объектов, без явной необходимости, используйте `Initialize`, чтобы сделать все, что вы хотели сделать в `New`. Это уменьшает количество функций вызываемых на этапе загрузки карты. Чтобы узнать больше про то, как работает `Initialize`, смотрите https://github.com/ChaoticOnyx/OnyxBay/blob/dev/code/game/atoms.dm

### Не используйте магические значения
Это касается различных переменных "mode", которые могут быть 1 или 2, но при этом неясно, что конкретно они означают. Используйте #define или локальные переменные, чтобы явно указать, что означает то или иное значение. Например:

```DM
/datum/proc/do_the_thing(thing_to_do)
	switch(thing_to_do)
		if(1)
			(...)
		if(2)
			(...)
```
Здесь неясно, что означают "1" и "2"! Вместо этого можно было бы написать:
```DM
#define DO_THE_THING_REALLY_HARD 1
#define DO_THE_THING_EFFICIENTLY 2
/datum/proc/do_the_thing(thing_to_do)
	switch(thing_to_do)
		if(DO_THE_THING_REALLY_HARD)
			(...)
		if(DO_THE_THING_EFFICIENTLY)
			(...)
```
Так получается гораздо понятнее, что увеличивает читаемость вашего кода.

### Операторы контроля выполнения
(if, while, for и другие)

* Все операторы контроля выполнения не должны содержать другого кода на той же строчке (`if (blah) return`)
* Все операторы контроля выполнения, сравнивающие переменную с каким-то значением, должны использовать формулу `переменная` `оператор` `значение`, не наоборот (например: `if (count <= 10)`, вместо `if (10 >= count)`)

### Используйте ранний return
Не стоит строчить многоуровневые конструкции из блоков if, когда того же результата можно достичь ранним возвратом из функции

Вот так делать не стоит:
````DM
/datum/datum1/proc/proc1()
	if (thing1)
		do stuff
		if (!thing2)
			do more stuff
			if (thing3 == 30)
				do extra stuff
````
А так уже лучше:
````DM
/datum/datum1/proc/proc1()
	if (!thing1)
		return
	do stuff
	if (thing2)
		return
	do more stuff
	if (thing3 != 30)
		return
	do extra stuff
````

### Разработка безопасного кода
* Всегда относитель к пользовательскому вводу так, как будто он намеренно пытается все сломать. Проверяйте пользовательский ввод на все случаи, которые не соответсвуют ожиданиям вашего кода. Для чисел проверяйте границы, для строк используйте escape-функции. Обратите внимание на функцию `sanitize`, которой удобно эскейпить вообще любой `input`, чтобы избежать ввод какого-то кода, который выполнится в браузере.
* Обязательно эскейптьте все команды к базе данных - используйте `sanitizeSQL` чтобы обработать весь текст от игроков и админов перед тем как передавать его в базу данных. Для чисел используйте `isnum`.
* Все вызовы топиков обязательно нужно проверять на их корректность. Такие вызовы могут быть подделаны со стороны клиента, поэтому их содержимым может быть что угодно!
* Скрывайте от игроков любую информацию, которая может быть использована для метагейма (даже такую простую, как количество игроков, которые нажали Declare, так как даже она может быть использована, чтобы вычислить текущий режим).
* Когда вы пишите код, который может каким-то образом влиять на раунд и генерировать *ВЕСЕЛЬЕ*, дважды проверьте, что такой функционал будет доступен только админам соответствующего ранга.

### Файлы
* Рантаймы не содержат полного пути до файла - поэтому избегайте одинаковых названий файлов даже в разных папках.
* Названия файлов не должны содержать пробелов или символов, которые придется эскейпить, указывая uri.
* Названия файлов и все пути всегда должны быть в нижнем регистре, чтобы избежать проблем, связанных с разным отношением к регистру в разных операционных системах.

### Фишки и лайфхаки Dream Maker
Как и любые другие языки, в BYOND есть свои особенности, которые стоит учитывать, чтобы писать более эффективный код. Тут описаны некоторые из них.

#### In-To for-loops
```for(var/i = 1, i <= some_value, i++)``` является стандартным способом писать циклы во многих языках программирования, однако в BYOND, внезапно, ```for(var/i in 1 to some_value)``` оказывается быстрее в плане производительности. (Обратите внимание, что ```to``` включает и левую, и правую границу).

ОДНАКО, если ```some_value``` или ```i``` меняются в течение цикла, или вы итерируете по элементам списка, длина которого изменяется, вы НЕ можете использовать этот тип цикла for.

### for(var/A in list) VS for(var/i in 1 to list.len)
По тестам производительности оказывается, что первый быстрее второго, поэтому без явных причин стоит использовать первый вариант.

## Global против static

В DM есть ключевое слово global, которое используется в трех случаях:

1. Внутри типа (или внутри функции) мы хотим определить переменную общую для всех объектов этого типа (для всех вызовов этой функции). (http://www.byond.com/docs/ref/#/var/global).
2. Внутри функции мы хотим использовать переменную из глобального скоупа, когда у нас в локальном скоупе уже есть переменная с таким же названием. (http://www.byond.com/docs/ref/#/proc/var/global)

Так как в первом случае речь идет не о видимости переменной, а том, что она общая для разных экземпляров типа (вызовов функции), то название ключевого слова global может кого-то запутать. Поэтому вместо него в первом случае мы стараемся использовать ключевое слово static, которое отсутствует в документации, но полностью заменяет global в этом случае и лучше описывает суть происходящего.

Отдельно обратите внимание, что все переменные в BYOND имеют глобальную видимость с точки зрения доступа, поэтому global (и static) в глобальном скоупе не имеет смысла и запрещено.

## Избегайте глобальных переменных

Главная проблема глобальных переменных в том, что чем больше они используются, тем сложнее понять логику их изменения и поведения процессов, которые от них зависят. Поэтому глобальные переменные лучше вовсе не использовать. Однако, если вам все-таки очень нужна глобальная переменная, то, как минимум, создавайте их на контроллере глобальных переменных, что даст чуть больше возможностей для их дебага:

Там все просто - вместо глобальных перменных нужно всегда использовать макросы (ну и конечно же лучше всего вообще не использовать глобальные переменные). Пример с тг:

Вместо:
```
var/X
var/list/Y
var/datum/genitalia/Z
var/A = 42
var/list/B = list(burn = "witch")
var/datum/genitalia/C = MakeAPenis()
var/hub_password
```

Используйте:
```
GLOBAL_VAR(X)
GLOBAL_LIST(Y)
GLOBAL_DATUM(Z, /datum/genitalia)
GLOBAL_VAR_INIT(A, 42)
GLOBAL_LIST_INIT(B, list(burn = "witch"))
GLOBAL_DATUM_INIT(C, /datum/genitalia, MakeAPenis())
GLOBAL_PROTECT(hub_password)
```
